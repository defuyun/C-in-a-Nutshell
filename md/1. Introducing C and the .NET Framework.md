# Introducing C# and the .NET Framework

## .NET Framework

the .net framework is a platform (or framework) that includes a Common Language Runtime (CLR) that execute the code

* C# code is compiled into a java bytecodeish format knpwn as IL (Intermediate language)
* CLR runs the bytecode in a JIT manner

it's a single large library containing all the basic functionality, which works best with windows

## Mono and Xaramin Project

aimed to make .NET cross platform, mainly used for

* mobile development
* building cloud services

## .NET Core

aimed to nugetize the components of .NET. removing parts of the .NET that isn't considered core anymore

.NET core has it's own cross platform CLR

* known as CoreCLR

and it contians a streamlined basic library of classes known as CoreFX

* UWP
* ASP.NET Core
* Entity Framework

they are all in the CoreFX library

## .NET standard

this is a standard for the 3 .NET libraries, why?

since we have 3 .NET platforms, .NET framework aimed at windows, Mono aimed at mobile and .NET Core aimed to be cross platform (mainly due to the use of cross platform CLR) they have differnt
api for the user to use. which means user for different platform may have to learn 3 different api, thus .NET Standard is born to set a common api interface for the 3 platforms

this is more a standard

## Writing and Compiling dotnet code

dotnet has a command line tool that is able to create projects, resolve dependency, run programs

the C# compiler used by dotnet CLI tool converts C# source code into IL and stores the IL in an assembly (either dll or exe)

IL code are semi assembly and will be exeuted by .NET core's virtual machine (like JVM) known as the CoreCLR

at runtime CoreCLR loads the IL from assembly JIT into native CPU and executes it

the core of dotnet compiler is the CoreCLR section which allows us to enter the same IL code on any machine (linux or windows), and CoreCLR will compile to the correct native os code

when you run `dotnet run` dotnet compiler compiles the code into IL and stores in the bin folder

## Memory Management

The Common Language Runtime ahas a garbage collector

## Storage Overhead

Technically the CLR position fields within a type (struct, class) that's a multiple of the fields size (maximum 8 byte) e.g. basically memory alignment based on the field size

```C#
struct A {
    byte b;
    long l;
}
```

in the example long takes up to 8byte thus the CLR would like to make it start at an address multiple of 8, therefore the actual layout of this struct in memory is something like

```C#
struct A {
    byte b; // 1byte data, 7byte payload, start 0, end 8byte
    long l; // 8byte data, start 8byte, end 16byte
}
```

thus wasting 16byte of data

you can override this behaviour with StructLayout attribute

Reference types (basically class objects which copies by reference) has overhead, an extra 4 or 8 bytes (depending on if your running x64 or x86) for each reference to the object
other than that, each object has a overhead of minimum 8byte to store

* a key to the object's type (reflection purpose)
* temporary information such as
  * lock state for multithreading
  * a flag to indicate whether it has been marked by the garbage collector (so possibly the address is gone by the next cycle)

## Number Conversion

use `System.Convert` to convert from float to int since it does rounding than just truncating

## String Types

C# allows verbatim string literals

```C#
string a2 = @"\\server\g\g"
```

basically the escape characters are not needed, special symbols are not recognized as special, just the strign literal

## Reference

C# reference on object and string is really a pointer e.g

```C#
void Foo(StringBuilder sb) {
    sb.Append("text");
    sb = null;
}

void Main() {
    var sb = new StringBuilder();
    Foo(sb);
    System.Console.WriteLine(sb);
}
```

the output of this snippet is `text`

the `sb` reference in `Foo` is actaully a pointer to `sb` in `Main`, therefore when we call `Append` we are modifying `sb` but when we try to set it to `null` it didn't affect `sb` in `Main`, to mimic real C++ reference we use the `ref` keyword by doing `ref StringBuilder sb` we specify that `sb` is the actual reference and any change to `ref` (reassign) will reassign the actual value

## Some Knack from trial and error

when you output a string with integer mixed e.g.

```C#
System.Console.WriteLine(10 + " " + 12);
```

if the integer is appended with a string the integer will be converted to string, but from my habit of using C++ I like to do

```C#
System.Console.WriteLine(10 + ' ' + 12);
```

in this case the char is converted to short therefore we actually output `10 + 32 + 12` which is an integer

## Extension Methods

extension methods are an extension on a existing class without changing anything in the class.

to create an extension method we need to create a `static` class as a __wrapper__

```C#
public static class StringHelper {
    public static bool IsCapitalized(this string s) {
        if (string.IsNullOrEmpty(s))
            return false;
        return char.IsUpper(s[0]);
    }
}
```

to satisfy as extension method we basically need

1. a static wrapper class
2. a static function with
    1. one parameter prefixed with the `this` keyword, which tells the compiler the current static function is an extension function on the class followed by `this`
    2. other parameters if needed

what I find retarded about this design is the need for a wrapper class, since it serves no other purpose other than wrapping the extension functions. I believe it should be possible to just have a stand alone function serve as an extension function

### Extension method vs Instance method

if ever a collision, instance method will take precedent over extension method

## Anonymous Types

in C# you can create anonymous type with the `var` keyword

```C#
var dude = new {Name = "Bob", Age = 23};
```

this is valid code that creates an anonymous type, the compiler compiles this code (at compile time) to

```C#
internal class Anon /* some generated name */ {
    private string name; // these variable names does not matter as they will be fetched via accessor
    private int age;

    public Anon(string name, int age) {
        this.name = name;
        this.age = age;
    }

    public string Name {get {return name; }}
    public int Age {get {return age;}}

    // Equals, GetHashCode etc
}

var dude = new Anon("bob", 23);
```

you cannot return an anonymous typed object, unless you define it with `dynamic` which is from `dynamic binding` (will get there eventually)

```C#
dynamic Foo() => new {Name = "Bob", Age = 30};
```

Anonymous types are used primarily when writing __LINQ__ q

## Tuple

tuple is not built into .NET framework 4.6, it relies on an assembly called `System.ValueTuple` so inorder to use tuple you need to explicitly include this assembly, it's by default included in .NET Framework 4.7

* tuples are value types, with mutable elements

you can give optional names to tuple values

```C#
(string Name, int Age) bob = ("Bob", 23);
Console.WriteLine(bob.Name);
Console.WriteLine(bob.Age);
```

C# handles tuple with a set of predefined generic structs

```C#
public struct ValueTuple<T1>;
public struct ValueTuple<T1,T2>;
public struct ValueTuple<T1,T2,T3>;
```

where each of them contains items named `Item1`, `Item2`, etc, when you create a tuple C# compiler converts it to one of these genric structs

the thing about named variables is that they disappear at runtime, the names will be transformed by the compiler at compile time back to `Item1`, `Item2`, this raises one issue is what if you want to use a named tuple you defined in another assembly.

this is where the exception comes in, with method/property that returns a named tuple, the compiler emits the element name by applying a custom attribute on the method/property called `TupleElementNamesAttribute` to the members return type.