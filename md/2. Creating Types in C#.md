# Creating Types in C\#

## Expression-Bodied Methods

in C# 7.0 you can use javascript arrow functions 

```C#
int Foo(int x) {return x * 2;}
```

can be rewritten as

```C#
int Foo(int x) => x * 2;
```

this works for constructor as well

## Pass by value and Pass by reference

when overloading, pass by value can coexist with pass by reference but not between pass by reference e.g.

```C#
void Foo(int x) {}
void Foo(ref int x) {} // Ok so far
void Foo(out int x) {} // compile error cannot have ref and out at the same time
```

Personally I consider this weird since you need to use the keywords `ref` and `out` when passing the pararmter so it's not hard to infer which overload I'm trying to call

## Deconstructors

C# Deconstructor is for outputing value, basically used to assign values e.g.

```C#
class Rectangle {
    public readonly float Width, Height;
    public Rectangle(float width, float height) {
        Width = width;
        Height = height;
    }

    public void Deconstruct(out float width, out float height) {
        width = Width;
        height = Height;
    }
}

void Main(string[] args)
{
    Rectangle rect = new Rectangle(10.0f, 12.0f);
    var (w,h) = rect;

    System.Console.WriteLine(rect.Width + " " + rect.Height);
    System.Console.WriteLine(w + " " + h);
}
```

this outputs

```md
10 12
10 12
```

do note it does not actually destroy the object, just a shorthand for assigning values

## Getter, Setter and Indexer

the setter has an implicit varaible called `value` that is passed in, it's value is equal to whatever the rhs of = is

note one interesting thing

```C#
class Rectangle {
    int number;

    public int Number {
        get {
            System.Console.WriteLine("Enter getter");
            return number;
        }

        set {
            System.Console.WriteLine("Enter setter");
            number = value;
        }
    }
}

void Main(string[] args)
{
    Rectangle rect = new Rectangle();
    rect.Number = 10;
    rect.Number -= 3;
}
```

in the code I did `rect.Number -= 3` this first triggered the getter, then minus 3, then called the setter with `value = original value - 3`

when CLR process getter and setter it first converts it into `get_XXX` and `set_XXX`, this is during the compiling step and IL are outputed

then these nonvirtual property accessors are inlined by the JIT compiler so in the end no function call is done and everything is the same as if we just accessed the fields themselves

some tricks you can do with setter and getter (property accessor) is limit the access to the variable

e.g. by doing

```C#
public int Number {get;} = 99;
```

* you have limited access to get only while setting the value to 99 (with field initalizer)
* this way no one can change the value, essentially creating a readonly variable

## Constants

the constant keyword on variables is treated exactly the same as constants that never have their address taken in C++, the values are substituted at compile time to the literal number

## Static Constructor

Static class Constructor (or static constructor) is ran only once per type, just before the type is envoked. By envoked I mean

```C#
class Test {
    static Test() {}
}
```

* Instantiating the type
* Accessing a static member in the type

as you can see static constructor does not mean static class

## Partial Types

the partial keyword allows you to split the class definition into 2 seperate files, basically multiple edits are possible. Also possible to be put on functions thus allowing header - implementation divide e.g.

```C#
// paymentForm.cs
partial class PaymentForm {
    partial validatePayment (decimal amount);
}

// paymentForm2.cs
partial class PaymentForm {
    partial validatePayment (decimal amount) {
        if (amount ....)
    }
}
```

in the example we used partial to seperate the files, a thing to note is that there is no return type specified, just partial that's because partial method only works for void

## Polymorthism

The `as` operator performs a downcast that evaluates to `null` if it fails. if you force downcast you will get `InvalidCastException` so decide what you use based on the need.

* it does not work on custom conversion
* it does not work on numeric e.g. `3 as long` would yield an compile time error

The `is` operator tests whether a reference conversion would succeed, in other words whether an object derives from a specified class

* returns true for unboxing conversion

from C# 7.0 you can combine the 2 operators by

```C#
if (a is Stock s)
    Console.WriteLine(s.SharesOwned);
```

so this combines `is` and `as` and it remains in-scope outside the `if` statement

## Boxing and Unboxing

When you cast a value type to object, CLR must perform some special work to bridge the difference in semantics between value and reference type. since value are by value and object (class) is by reference