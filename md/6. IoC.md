# .NET IoC

IoC, oftened seen with the list

* IoC
* Dependency Inversion Principle (DIP)
* Dependency Injection (DI)
* IoC container

![ic][ioc]

[ioc]: images/ioc.PNG

## Summary

1. IoC is a design _principle_ that looks to __inverse__ control in object oriented programming.

    * control means any additional responsiblity that a class has other than it's main objective. for example creating the dependent classes.

    this itself does not explain much, basically we want loose coupling and the concept is similar to a factory pattern

2. DIP (_principle_) suggests that high-level modules should not be dependent on low-level modules but should depend on abstraction.

    so a filesystem class should implement on a disk abstraction rather than a disk class, in other words it should not have control over what disk it's gonna get

3. DI is a _pattern_ that implements IoC _principle_

4. The IoC Container is a framework that aims to automate the DI process. Such as the _Unity_ framework in .NET

    we cannot achieve loosely coupled classes by only using IoC _principle_ (as it doens't make much sense in itself)

## Inversion of Control

![if][icoflow]

[icoflow]: images/iocflow.PNG

form the graph, IoC can be achieved using Factory Pattern, example using __C++__

```C++
class Driver {
public:
    Driver() {
        // driver stuff
    }
};

class Car {
private:
    Driver driver;

public:
    Car(): driver(new Driver()) {}
    void Run(); // man functionality
};
```

in the first example class Car creates Driver, so other than the main function driving, it involves the additional control of creating the driver

IoC principle suggests to invert the control, which actually means:

* transfer the extra control stuff to another class

to link this with invert control, understand it like this

* invert the dependency creation control from `class Car` to another class

or just forget the invert and just remember moving the responsible of extra control to another function

```C++
class Driver {
public:
    void Drive();
}

class DriverFactory {
public:
    static Driver createDriver() {
        // create new driver return the interface
    }
};

class Car {
private:
    Driver driver;

public:
    Car() {
        driver = DriverFactory.createDriver();
    }

    void Run(); // man functionality
};
```

the responsibility of creating a driver is moved to another class, this decouples the Car from Driver, so factory to can anything when creating the object.

In summary the simple Factory Pattern is our solution for IoC, which is just

* transfer the exrta control functionality to another class, or formaly inverting the dependency of control to another class

## Dependency Inversion Principle

![idi][di]

[di]: images/di.PNG

DIP, roughly translates to interface

it literally says, high module should not depend on low level but rather on abstraction, abstraction can be directly translated to interface.

so how do we write code?

using previous example we only need to change a little code

```C++
class IDriver {
public:
    virtual void Drive() = 0;
}

class DriverFactory {
public:
    static IDriver createDriver() {
        // create new driver return the interface
    }
};

class Car {
private:
    IDriver driver;

public:
    Car() {
        driver = DriverFactory.createDriver();
    }

    void Run(); // man functionality
}
```

we now create driver abstractions instead of the actual driver, now the car don't even know what driver is using it, as long as it can drive. which decouples it even more

## Dependency Injection

![idc][dic]

[dic]: images/dic.PNG

now this section we are going to implement dependency injection, this is really simple, basically we are going to replace the factory with 3 different types of method.

before we start let's introduce some jargons

![idi][dipt]

[dipt]: images/dicpat.PNG

so the jargons are

* Client Class: The class that needs the additional control
* Service Class: The class being injected
* Injector: The class that injects the Service into the Client

now this is clear, let's introduce our 3 methods of replacing the factory.

so, since we need to replace, we need to give reasons to why the factory was not enough

```C++
class IDriver {
public:
    virtual void Drive() = 0;
}

class DriverFactory {
public:
    static IDriver createDriver() {
        // create new driver return the interface
    }
};

class Car {
private:
    IDriver driver;

public:
    Car() {
        driver = DriverFactory.createDriver();
    }

    void Run(); // man functionality
}
```

now if we look back to this code snippet, the reason lies in the `DriverFactory` that was used in the `Car` class. In some way we are still exposing the dependency inside our class, consider if we need complicated logic to determine our runtime Driver