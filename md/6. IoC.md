# .NET IoC

IoC, oftened seen with the list

* IoC
* Dependency Inversion Principle (DIP)
* Dependency Injection (DI)
* IoC container

![ic][ioc]

[ioc]: ioc.png

## Summary

### IoC

IoC is a design _principle_ that looks to __inverse__ control in object oriented programming.

* control means any additional responsiblity that a class has other than it's main objective. for example creating the dependent classes.

this itself does not explain much, basically we want loose coupling and the concept is similar to a factory pattern

### Dependency Inversion Principle

DIP (_principle_) suggests that high-level modules should not be dependent on low-level modules but should depend on abstraction.

so a filesystem class should implement on a disk abstraction rather than a disk class, in other words it should not have control over what disk it's gonna get

### Dependency Injection

DI is a _pattern_ that implements IoC _principle_

### IoC Container

The IoC Container is a framework that aims to automate the DI process. Such as the _Unity_ framework in .NET

we cannot achieve loosely coupled classes by only using IoC _principle_ (as it doens't make much sense in itself)

## Inversion of Control

![if][icoflow]

[icoflow]: icoflow.png

form the graph, IoC can be achieved using Factory Pattern, example using __C++__

```C++
class Driver {
public:
    Driver() {
        // driver stuff
    }
};

class Car {
private:
    Driver driver;

public:
    Car(): driver(new Driver()) {}
    void Run(); // man functionality
};
```

in the first example class Car creates Driver, so other than the main function driving, it involves the additional control of creating the driver

IoC principle suggests to invert the control, which actually means:

* transfer the extra control stuff to another class

to link this with invert control, understand it like this

* invert the dependency creation control from `class Car` to another class

or just forget the invert and just remember moving the responsible of extra control to another function

```C++
class Driver {
public:
    virtual void Drive() = 0;
}

class DriverFactory
public:
    static IDriver createDriver() {
        // create new driver return the interface
    }
};

class Car {
private:
    IDriver driver;

public:
    Car() {
        driver = DriverFactory.createDriver();
    }

    void Run(); // man functionality
};
```

the responsibility of creating a driver is moved to another class, this decouples the Car from Driver, in that the Car does not care what driver it get's it just need to Run with any Driver

In summary the simple Factory Pattern is our solution for IoC, which is just

* transfer the exrta control functionality to another class, or formaly inverting the dependency of control to another class

##