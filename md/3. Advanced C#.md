# Advanced C\#

## Delegates

delegates are basically `std::function<T(T)>` in C++

### Multicast Delegates

you can add multiple function to a single delegate by doing

```C#
someDelegate d = someMethod1;
d += someMethod2;
```

you can also remove method with `-=`

note: delegates are immutable, when you do `+=` you are creating a new delegate instance and assigning back to the old variable name

if the multicast delegate is not null return then the last invoked method return value is returned

### Instance

when using a instance method with delegate there is a `Target` field in the delegate that stores the instance

in multicast case it stores the last instance and method

### Polymorthism

Delegate follows polymorthism needs

Delegate works by

* calling delegate
* delegate calls underlaying functions

this means we can allow

* the parameter from delegate to function to upcast
* the return value from function to delegate to upcast

## Events

the purpose of `event` is to encapsulate the delegate. Usage example is as follows

```C#
public delegate void PriceChangedHandler(decimal oldPrice, decimal newPrice);

public class BroadCaster {
    public event PriceChangedHandler handler;
}
```

by adding the event keyword infront of `handler` we can limit outer access to this delegate to only adding and removing

* essentially the `event` keyword makes `Invoke` to `handler` private
* but `+=` and `-=` is still public

under the hood, when C# compiles this the code is transformed to roughly as follows

```C#
public class BroadCaster {
    PriceChangedHandler priceChange; // this is private
    public event PriceChangedHandler PriceChanged {
        add { ... }
        remove { ... }
    }
    // add and remove are, well, special accessors for the delegate, they are called event accessors
}
```

Not only does C# provide us with a `event` keyword, it also "recommends" us a pattern, the key to the pattern is the `EventHandler<TEvent>` class, which is a delegate defined as

```C#
delegate void EventHandler<TEventArgs>(Object source, TEventArgs e) where e : System.EventArgs;
```

this is the C# default `EventHandler` where you have 2 parameter inputs

* source is the class that the event is acting on
* e is the event arguments, it's the parameters that are involved with the change

this is kind of like the command system wargamming did to implement their undo/redo function (at the time)

an example of the pattern is listed below

a note on the lambda function

* at first I tried to define the lambda as `Action<int,int>`
* then attach this `action` to the `EventHandler`
* in essense `Action` and `EventHandler` resolve to the same type, the delegate is both `void (int, int)`
* but I forgot that delegates are different even when the syntax is exactly the same
* so even though `Action` and `EventHandler` is essentially the same funciton signature
* they are not the same delegate so instance of `Action` cannot be assigned to type of `EventHandler`

therefore if we want to define a lambda for `EventHandler` we need to define it as `EventHandler` type

```C#
public class PriceChangedEventArgs : System.EventArgs {
    public readonly float oldPrice;
    public readonly float newPrice;

    public PriceChangedEventArgs (float oldPrice, float newPrice) {
        this.oldPrice = oldPrice;
        this.newPrice = newPrice;
    }
}

public class Stock {
    float price;

    public event EventHandler<PriceChangedEventArgs> PriceChanged;
    // this is defined as delegate void EventHandler<Object, TEvent> (object source, TEvent evt);

    protected virtual void OnPriceChanged(PriceChangedEventArgs e) {
        PriceChanged?.Invoke(this, e);
    }

    public float Price {
        set {
            if (price == value) return;
            PriceChangedEventArgs args = new PriceChangedEventArgs(price, value);
            price = value;
            this.OnPriceChanged(args);
        }
        get {
            return price;
        }
    }
}

static void Main(string[] args)
{
    Stock stock = new Stock();

    EventHandler<PriceChangedEventArgs> cb = (Object o, PriceChangedEventArgs e) => {
        Stock t = o as Stock ?? new Stock();
        System.Console.WriteLine(t.Price);  
        System.Console.WriteLine(e.oldPrice);  
    };

    stock.PriceChanged += cb;
    stock.Price = 12;
}
```

## Lambda

A lambda expression is an unnamed method written in place of a delegate instance

* the compiler converts the lambda into either
  * a delegate instance
  * an expression tree, of type `Expression<TDelegate>`
    * this allows the lambda to be stored as a traversable object model, which can be interpreted later at runtime

but really, mostly you will use lambda as a delegate

## Exception

in C# 6.0, you can specify an exception filter in a __catch__ clause by adding a __when__ clause

```C#
catch(WebException ex) when (ex.Status = WebExceptionStatus.Timeout) {
    ...
}
```

you can rethrow exceptions

```C#
catch(WebException ex) {
    Console.WriteLine(ex.StackTrace);
    throw;
}
```

the `using` keyword, (same as `open with` in python), used with class that implements the `IDisposable` interface, which defines a single parameterless `Dispose` function that cleans up the resource within a `finally` block

```C#
using (StreamReader reader = File.OpenText("file.txt")) {
    ...
}
```

this is equivalent to

```C#
{
    StreamReader reader = File.OpenText("file.txt");
    try {
        ...
    }
    finally {
        reader?.Dispose();
    }
}
```

basically `using` converts to the catching snippet which allows memory to be deallocated correctly even when exception occurs;

key properties of `System.Exception`

* StackTrace: a string representing all the mehtods that are called from the origin of the exception to the catch block
* Message: a string with a description of the error
* InnerException: the inner exception that caused the outer exception

### The TryXXX Pattern

the try pattern has syntax

```C#
public bool TryParse(string input, out int returnValue);
```

it silents the exception of `Parse` and outputs into `returnValue`

## Nullable Types

reference types can use `null` to represent non existence. Value types however cannot. Thus C# introduces a class for representing `null` value type.

the Nullable struct looks like

```C#
public struct Nullable<T> where T : struct {
    public T Value {get;}
    public bool HasValue {get;}
    public T GetValueOrDefault();
    public T GetValueOrDefault(T defaultValue);
}
```

when we do

```C#
int? i = null;
Console.WriteLine(i == null);
```

translates to

```C#
Nullable<int> i = new Nullable<int>();
Console.WriteLine(! i.HasValue);
```

we can of course create `Nullable` on our own instead of relying on translation by the compiler, in which case

* if we try to access `Value` when `HasValue` is false, we get an `InvalidOperationException`

and we can do direct call to `GetValueOrDefault`, which in the case that `HasValue` is false we get a default depending on which overload we call

### Implicit and Explcit Nullable Conversion

converting from `T` to `T?` is implicit, but `T?` to `T` is explicit

```C#
int? x = 5 // implicit from int to int?
int y = (int)x // need explictly convert
```

* the explicit cast is equivalent to calling the `Value` property

a scenario of nullable types is in SQL, because some `int` column can be null, therefore when communicating with the db we may want Nullable ints in our ORM